import sys
import os
import configparser
import requests
from time import time

class StravaUnauthorizedException(Exception):
    """
    Raised in case of 401 Unauthorized response
    """
    pass

class StravaForbiddenException(Exception):
    """
    Raised in case of 403 Forbidden response
    """
    pass

class StravaNotFoundException(Exception):
    """
    Raised in case of 404 Not found response
    """
    pass

class StravaRateLimitException(Exception):
    """
    Raised in case of 429 Too Many Requests response. (100 per 15min or 1000 per day)
    """
    pass

class StravaUndefinedResponseException(Exception):
    """
    Raised in case a non-defined response was received.
    """
    def __init__(self, responsecode) -> None:
        super().__init__(f"Received response code {responsecode} is not defined in Strava API.")


class StravaConnector():
    def __init__(self, authconfigpath) -> None:
        self.authorization_url = 'http://www.strava.com/oauth/authorize'
        # TODO: is it https://www.strava.com/api/v3/oauth/token?
        self.token_url = 'https://www.strava.com/oauth/token'
        self.athlete_url = 'https://www.strava.com/api/v3/athlete'
        self.activities_url = 'https://www.strava.com/api/v3/athlete/activities'
        self.detailed_activity_url = 'https://www.strava.com/api/v3/activities/' # needs {id}/ at the end
        self.auth_config = configparser.ConfigParser()
        self.auth_config_path = authconfigpath

    def convert_response_to_json(self, r) -> dict:

        # check for ok response (200)
        if r.status_code == requests.codes.ok:
            
            # return json-formatted response data
            return r.json()

        elif r.status_code == requests.codes.unauthorized:
            raise StravaUnauthorizedException

        elif r.status_code == requests.codes.forbidden:
            raise StravaForbiddenException

        elif r.status_code == requests.codes.not_found:
            raise StravaNotFoundException

        elif r.status_code == requests.codes.too_many_requests:
            raise StravaRateLimitException

        else:
            raise StravaUndefinedResponseException(r.status_code)

    
    def oauth_get_code(self, id, scope, redirecturi) -> str:
        """
        Actually get a code by authorizing app via redirect url
        """
        # first run probably needs actual client authentication
        # http://www.strava.com/oauth/authorize?client_id=76303&response_type=code&redirect_uri=http://localhost/exchange_token&approval_prompt=force&scope=read_all,profile:read_all,activity:read_all

        # build parameters
        params = {'client_id': id,
                  'redirect_uri': redirecturi,
                  'response_type': 'code',
                  'approval_prompt': 'force',
                  'scope': scope}
        # TODO: actual authentication, for now just build and return string
        s = self.authorization_url + '?'
        for param in params:
            if params[param] == list(params)[-1]:
                # don't add '&' for last entry of list
                s += param + '=' + params[param]
            else:
                s += param + '=' + params[param] + '&'

        return s
        

    def oauth_get_token_from_code(self, id, secret, code) -> None:
        """
        Get tokens (access_token, refresh_token) from one-time code generated by manual authorization.
        """
        # get tokens from code
        tokendata = {'client_id': id, 
                     'client_secret': secret,
                     'code': code,
                     'grant_type': 'authorization_code'
                     }
        r = requests.post(url=self.token_url, data=tokendata)

        # write tokens to config
        try:
            token = self.convert_response_to_json(r)
        except StravaRateLimitException:
            # TODO do something
            print(f"Rate limit exception, try again later :)")
            sys.exit(429)
        else:
            # update config
            self.auth_config['Strava'] = {}
            self.auth_config['Strava']['access_token'] = token['access_token']
            self.auth_config['Strava']['refresh_token'] = token['refresh_token']
            self.auth_config['Strava']['expires_at'] = str(token['expires_at'])

        # save auth.cfg file
        self.save_auth_config()


    def oauth_refresh_access_token(self, id, secret) -> None:
        """
        Get new tokens (access_token, refresh_token) from refresh_token if expired.
        """
        currepoch = int(time.time())
        try:
            # check if access token has timed out
            if currepoch > int(self.auth_config['Strava']['expires_at'], base=10):
            
                # get new tokens from refresh_token
                refreshdata = {'client_id': id,
                            'client_secret': secret,
                            'refresh_token': self.auth_config['Strava']['refresh_token'],
                            'grant_type': 'refresh_token'
                            }
                r = requests.post(url=self.token_url, data=refreshdata)

                try:
                    token = self.convert_response_to_json(r)
                except StravaRateLimitException:
                    # TODO do something
                    print(f"Rate limit exception, try again later :)")
                    sys.exit(429)
                else:
                    # update config parameters (is saved to auth.cfg)
                    self.update_auth_config(section='Strava',
                                            access_token=token['access_token'],
                                            refresh_token=token['refresh_token'],
                                            expires_at=str(token['expires_at']))
            else:
                # access token is available and still valid
                # TODO: log something
                pass
         
        except configparser.NoSectionError:
            # catch config not found errors
            sys.exit(500)


    def load_auth_config(self) -> bool:
        """
        Load auth.cfg from given path if exists (returns True).
        If auth.cfg does not exist, returns False.
        """
        # check if auth.cfg exists
        if os.path.exists(self.auth_config_path):
            self.auth_config.read(self.auth_config_path, encoding='utf-8')
            return True
        else:
            # TODO: write new auth.cfg
            return False
            raise Exception("No auth.cfg found!")


    def save_auth_config(self) -> None:
        """
        Save auth.cfg to given path
        """
        # save auth.cfg to file
        if not os.path.exists(os.path.dirname(self.auth_config_path)):
            os.mkdir(os.path.dirname(self.auth_config_path))
        with open(self.auth_config_path, 'w') as f:
            self.auth_config.write(f)


    def update_auth_config(self, section, **configargs) -> None:
        """
        Update one or multiple configuration parameters in given section and save to auth.cfg
        """
        # TODO: handle section not existing!
        for arg in configargs:
            self.auth_config.set(section=section, 
                                 option=arg, 
                                 value=configargs[arg])

        # save config after update
        self.save_auth_config()


    def get_athlete_data(self) -> dict:
        return None


    def get_athlete_activities(self) -> dict:
        return None


    def get_detailed_activity(self) -> dict:
        return None

